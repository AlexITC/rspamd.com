---
layout: doc
title: Использование fuzzy хешей
---

# Использование fuzzy хешей

## Введение

Нечеткие хеши (fuzzy hashes) используются для поиска **похожих** писем - то есть, при помощи такого метода можно найти сообщения, которые содержат такой же или незначительно измененный текст. Данная технология хорошо подходит для блокировки спам-рассылок, которые отправляются сразу многим пользователям. Так как хеш функция однонаправлена, то восстановить исходный текст, имея только хеш, невозможно, что позволяет отправлять запросы на сторонние хранилища хешей без риска раскрытия информации.

Хочется отметить, что нечеткие хеши работают не только для текстовых данных, но и для картинок и других вложений в письмах. Однако в таком случае пропадает элемент нечеткой логики, и rspamd ищет точные соответствия для подобных объектов.

Данная статья предназначена для администраторов почтовых систем, которые хотят создать собственное хранилище хешей и обучать его самостоятельно.

## Шаг 1: выбор источников хешей

В первую очередь необходимо выбрать источники образцов спама для обучения. Основной принцип - использование для обучения спам-рассылок, которые приходят многим пользователям. Существует два основных подхода к решению подобной задачи:

- использование жалоб пользователей;
- создание ловушек для спама (honeypot).

### Использование жалоб пользователей

Пользователи являются одним из ресурсов, позволяющих оценивать качество работы системы фильтрации спама, поэтому желательно предусмотреть механизм использования жалоб пользователей для обучения хранилища хешей. К сожалению, пользователи часто жалуются и на легитимные письма, на которые они сами же и подписались: рассылки магазинов, уведомления от систем бронирования билетов и даже на личные письма, которые им по каким-то причинам не нравятся. Многие пользователи просто не видят разницу между кнопками "удалить" и "пожаловаться на спам". Возможно, хорошей идеей будет запросить у пользователя дополнительную информацию о жалобе, например, почему он считает, что это письмо спам, а так же обратить внимание пользователя на то, что он может отписаться от получения рассылок.

Другим способом решения этой проблемы является ручная обработка жалоб пользователей на спам или же комбинация методов: назначить бОльший вес письмам, обработанным вручную, и меньший - всем остальным жалобам.

В rspamd также есть две возможности, позволяющие отсеивать некоторые "ложные" срабатывания:

1. Вес хеша.
2. Фильтры обучения.

Первый метод довольно прост: давайте назначим каждой жалобе некоторый вес и при каждом обучении будем прибавлять его к сохраненному значению соответствующего хеша. При проверке мы не будем учитывать хеши, вес которых меньше заданного порога. Например, если вес жалобы w=1, а порог срабатывания t=20, то для начала срабатывания хеша необходимо как минимум 20 жалоб пользователей. Кроме этого, при проверке для хеша, превышающего пороговое значение, rspamd назначает не максимальные очки, а их величина плавно растет от нуля до максимума (до значения метрики) при изменении веса хеша от порогового до удвоенного порогового значения (t .. 2*t).

<center><img class="img-responsive" src="/img/rspamd-fuzzy-1.png" width="50%"></center>

Второй метод - фильтры обучения - позволяет написать некоторые условия на языке Lua, которые запрещают обучение, скажем, для писем с определенного домена (например, facebook.com). Возможности фильтров достаточно обширны, но требуют ручной работы по их настройке.

### Настройка ловушек спама

Для данного метода необходимо иметь такие почтовые адреса, на которые не приходит легитимная почта, зато приходит много спама. Основная идея заключается в том, чтобы "засветить" адрес в базах спамеров, не показывая его легитимным пользователям. Для этого можно, например, разместить на достаточно популярном веб-сайте элемент *iframe*, который не отображается пользователям (имеет свойство *hidden* или нулевой видимый размер), но содержит доступные ботам email-адреса ловушек. В последнее время этот метод стал не очень эффективен, так как спамеры научились обходить такие приемы.

Другой возможный способ создания ловушки - это поиск доменов, бывших ранее популярными, но не работающих в настоящее время (адреса из этих доменов находятся во многих спамерских базах). В этом случае нужны фильтры обучения, так как высока вероятность того, что в "черный" список попадут легитимные письма, например, от социальных сетей или служб рассылки.

В целом, создание собственных ловушек оправдано только в случае большой почтовой системы, так как это может быть затратно как в плане трудности сопровождения, так и в виде прямых материальных расходов на покупку доменов.

## Шаг 2: Настройка хранилища

В данной главе я рассмотрю основные настройки хранилища и как оптимизировать его работу.
**Важное замечание:** хранилище работает не с письмами, а с готовыми хешами. То есть, чтобы преобразовать письмо в его хеш нужен отдельный процесс сканера или контроллера:

<center><img class="img-responsive" src="/img/rspamd-fuzzy-2.png" width="75%"></center>

Функции хранилища:

1. Хранение и проверка хешей
2. Транспортное шифрование протокола
3. Удаление устаревших хешей
4. Контроль доступа (как на запись, так и на чтение)
5. Репликация (с версии 1.3)


### Архитектура хранилища

Для хранения данных используется sqlite, что накладывает некоторые ограничения на архитектуру хранилища. Во-первых, sqlite крайне плохо работает при конкурентных запросах на запись: в этом случае производительность этой СУБД падает на несколько порядков. Во-вторых, невозможно обеспечивать репликацию и масштабирование средствами самой БД. Ну и в-третьих, sqlite работает быстро (особенно когда данные умещаются в RAM) и позволяет обрабатывать сотни тысяч запросов на чтение в секунду.

В связи с этим, хранилище хешей rspamd всегда выполняет запись в БД строго из одного процесса. Для этого один из процессов ведет очередь обновлений, а остальные процессы просто передают запросы на запись от клиентов в эту общую очередь. Очередь сбрасывается на диск раз в минуту по умолчанию. Таким образом, хранилище рассчитано на профиль нагрузки с преобладанием запросов на чтение.

### Устаревание хешей

Другой важной задачей хранилища является процесс удаления устаревших хешей из базы. Дело в том, что рассылки спама носят достаточно ограниченный по времени характер, и нет никакого смысла хранить абсолютно все хеши за все время. Разумным будет определить количество хешей, которые приходят на обучение и размер оперативной памяти, достаточный для их хранения, чтобы определить, насколько долго можно хранить хеши. Например, 400 тысяч хешей занимают около 100 мегабайт, а полтора миллиона хешей занимают уже полгигабайта. Не рекомендуется иметь базу, чей размер превышает размер доступной оперативной памяти из-за высокого риска значительного ухудшения производительности. Кроме того, нет особого смысла хранить хеши дольше, чем приблизительно три месяца. Поэтому, если у вас небольшое количество хешей пригодных для обучения, лучше установить устаревание в 90 дней, уменьшая его в соответствие с доступной оперативной памятью и размером базы данных.

### Пример настройки

Для того, чтобы создать собственное хранилище, необходимо сконфигурировать процесс `fuzzy_storage`. Это лучше всего делать в локальном файле конфигурации: `etc/rspamd/rspamd.conf.local`:

~~~ucl
worker "fuzzy_storage" {
  # Socket to listen on (UDP and TCP from rspamd 1.3)
  bind_socket = "*:11335";

  # Number of processes to serve this storage (useful for read scaling)
  count = 4;

  # Where data file is stored (must be owned by rspamd user)
  database = "${DBDIR}/fuzzy.db";

  # Hashes storage time (3 months)
  expire = 90d;

  # Synchronize updates to the storage each minute
  sync = 1m;
}
~~~

### Настройки доступа

По умолчанию, rspamd не разрешает модификаций в хранилище, что означает невозможность обучения. Для того, чтобы обучение было возможно, необходимо задать список доверенных ip адресов или сетей. Как правило, лучше всего разрешить такие операции только с локального адреса (127.0.0.1), так как fuzzy storage использует UDP, который не имеет никакой защиты от подделки IP адреса источника (что можно исправить путем настройки верификации обратного маршрута на маршрутизаторе, но это зачастую игнорируется системными администраторами):

~~~ucl
worker "fuzzy_storage" {
  # Same options as before ...

  allow_update = ["127.0.0.1"];

  # or 10.0.0.0/8, for internal network
}
~~~

Также для разграничения доступа может использоваться транспортное шифрование, которое мы рассмотрим далее.

### Транспортное шифрование

Протокол работы с хранилищем хешей позволяет включать необязательное или обязательное шифрование. Архитектура шифрования основана на конструкции cryptobox: <https://nacl.cr.yp.to/box.html> и похожа на алгоритм end-to-end шифрования dnscurve: <https://dnscurve.org/>. В данной статье я не буду углубляться в рассмотрение деталей реализации протокола, однако необходимо заметить, что в данной системе необходимо вручную создать ключевую пару на сервере хранилища, что удобно делать командой `rspamadm keypair -u`:

```
% rspamadm keypair -u
keypair {
    pubkey = "og3snn8s37znxz53mr5yyyzktt3d5uczxecsp3kkrs495p4iaxzy";
    privkey = "o6wnij9r4wegqjnd46dyifwgf5gwuqguqxzntseectroq7b3gwty";
    id = "f5yior1ag3csbzjiuuynff9tczknoj9s9b454kuonqknthrdbwbqj63h3g9dht97fhp4a5jgof1eiifshcsnnrbj73ak8hkq6sbrhed";
    encoding = "base32";
    algorithm = "curve25519";
    type = "kex";
}
```

Данная команда создает **уникальную** пару ключей, в которой **публичный** ключ должен быть скопирован вручную на клиенты (например, через ssh) или же опубликован неким безопасным способом (например, подписан gpg ключем или опубликован на https сайте). Приватный ключ должен храниться в секрете. Каждое хранилище может работать одновременно с произвольным числом ключей:

~~~ucl
worker "fuzzy_storage" {
  # Same options as before ...
  keypair {
    pubkey = ...
    privkey = ...
  }
  keypair {
    pubkey = ...
    privkey = ...
  }
  keypair {
    pubkey = ...
    privkey = ...
  }
}
~~~

Эта возможность полезна для создания закрытых хранилищ, где доступ разрешен только тем клиентам, которым известен один из публичных ключей:

<center><img class="img-responsive" src="/img/rspamd-fuzzy-3.png" width="75%"></center>

Для принудительного включения режима шифрования используется опция `encrypted_only`:

~~~ucl
worker "fuzzy_storage" {
  # Same options as before ...
  encrypted_only = true;

  keypair {
    ...
  }
  ...
}
~~~

### Проверка работы хранилища

Для проверки работы хранилища используется команда `rspamadm control fuzzystat`:

```
Statistics for storage 73ee122ac2cfe0c4f12
invalid_requests: 6.69M
fuzzy_expired: 35.57k
fuzzy_found: (v0.6: 0), (v0.8: 0), (v0.9: 0), (v1.0+: 20.10M)
fuzzy_stored: 425.46k
fuzzy_shingles: (v0.6: 0), (v0.8: 41.78k), (v0.9: 23.60M), (v1.0+: 380.87M)
fuzzy_checked: (v0.6: 0), (v0.8: 95.29k), (v0.9: 55.47M), (v1.0+: 1.01G)

Keys statistics:
Key id: icy63itbhhni8
        Checked: 1.00G
        Matched: 18.29M
        Errors: 0
        Added: 1.81M
        Deleted: 0

        IPs stat:
        x.x.x.x
                Checked: 131.23M
                Matched: 1.85M
                Errors: 0
                Added: 0
                Deleted: 0

        x.x.x.x
                Checked: 119.86M
                ...
```

Таким образом, вначале отображается общая статистика хранилища: количество сохраненных хешей, количество устаревших хешей. Также отображается статистика запросов по версиям rspamd:

* `0.6` - устаревшая версия rspamd 0.6 до rspamd 0.8 (ограниченно совместимы)
* `0.8` - запросы от версии 0.8 до 0.9 (частично совместимы)
* `0.9` - незашифрованные запросы от rspamd 0.9 до rspamd 1.3 (полностью совместимы)
* `1.1` - зашифрованные запросы от rspamd 1.1 до rspamd 1.3 (полностью совместимы)
* `1.3` - зашифрованные и незашифрованные запросы от rspamd 1.3+

Далее по каждому из ключей, сконфигурированных в хранилище, отображается подробная статистика по последним встреченным ip адресам. И в заключение можно увидеть общую статистику по адресам.

Вывод этой команды можно изменять следующими опциями (например, `rspamdadm control fuzzystat -n`):

* `-n`: выводить "сырые" числа без сокращения
* `--short`: не выводить подробную статистику ключей и ip
* `--no-keys`: не выводить статистику ключей
* `--no-ips`: не выводить статистику по ip адресам
* `--sort`: задать порядок сортировки:
  + `checked`: по числу проверенных хешей (по умолчанию)
  + `matched`: по числу найденных хешей
  + `errors`: по числу ошибочных запросов
  + `ip`: по ip адресу лексикографически

Хранилище хешей также отвечает за репликацию, но я несколько отложу рассмотрение этой темы и перейду к описанию клиентской части - плагина `fuzzy_check`.

## Шаг 3: Настройка плагина `fuzzy_check`

Плагин `fuzzy_check` отвечает как за проверку хешей, так и за обучение. Его задачами являются:

1. Обработка писем и создание хешей на их базе
2. Отправка запросов к хранилищу
3. Транспортное шифрование

Необходимо отметить, что плагин используется и процессами-сканерами для проверки писем, и процессами-контроллерами для обучения хранилища. Обучение осуществляется командой `rspamc fuzzy_add`:

```
$ rspamc -f 1 -w 10 fuzzy_add <message|directory|stdin>
```

Сразу же бросаются в глаза дополнительные параметры `-w` и `-f`. Первый из них - `-w` - означает вес хеша, который мы обсуждали ранее. Второй - `-f` - означает номер флага. Флаги позволяют хранить хеши различного происхождения в хранилище. Например, хеши спам-ловушек и хеши жалоб или же хеши писем из "белого" списка. Каждый флаг может быть ассоциирован с собственным символом и, соответственно, иметь собственный вес при проверке письма:

<center><img class="img-responsive" src="/img/rspamd-fuzzy-4.png" width="75%"></center>

Для того, чтобы rspamd мог соотносить флаги и символы, их нужно настроить в конфигурации плагина `fuzzy_check`. Эти настройки находятся в секции `rule`, которая определяет флаги, символы и адреса хранилища хешей. Приведем пример настройки данной секции:

~~~ucl
fuzzy_storage {
  # Global options

  # Rule definition
  rule "rspamd.com" {
    # Fuzzy storage servers list
    servers = "rspamd.com:11335";

    # Public key for transport encryption
    encryption_key = "icy63itbhhni8bq15ntp5n5symuixf73s1kpjh6skaq4e7nx5fiy";

    # Symbol for unknown flags
    symbol = "FUZZY_UNKNOWN";

    # Additional mime types to store within fuzzy storage
    mime_types = ["application/*"];

    # Hash weight threshold
    max_score = 20.0;

    # Whether we can learn this fuzzy
    read_only = yes;

    # Ignore unknown flags
    skip_unknown = yes;

    # Hashes generation algorithm
    algorithm = "siphash";

    # Map flags to symbols
    fuzzy_map = {
        # Key is symbol name
        FUZZY_DENIED {
            # Local threshold
            max_score = 20.0;
            # Flag to match
            flag = 1;
        }
        FUZZY_PROB {
            max_score = 10.0;
            flag = 2;
        }
        FUZZY_WHITE {
            max_score = 2.0;
            flag = 3;
        }
    }
  }
}
~~~

Рассмотрим некоторые полезные опции, которые можно настраивать в модуле.

Во-первых, `max_score` полезен для задания веса порога срабатывания данного хеша:

<center><img class="img-responsive" src="/img/rspamd-fuzzy-1.png" width="50%"></center>

Вторым полезным параметром является `mime_types`, который определяет, какие вложения также проверять (и обучать!) в данном хранилище. Этот параметр представляет собой список допустимых типов в формате `["type/subtype", "*/subtype", "type/*", "*"]`, где `*` заменяет любой допустимый тип. Как правило, достаточно полезно сохранять хеши всех `application/*` вложений. Кроме того, вложенные изображения проверяются в хранилище неявно (то есть, нет нужды добавлять `image/*` в список проверяемых вложений). Стоит иметь в виду, что вложения и изображения проверяются на точное соответствие, в отличие от текстов, которые могут немного отличаться.

Важным параметром, если вы хотите обучать ваше хранилище, является параметр `read_only`. По умолчанию он включен, что означает невозможность обучения хранилища:

~~~ucl
read_only = true; # disallow learning
read_only = false; # allow learning
~~~

Параметр `encryption_key` задает **публичный** ключ хранилища и включает шифрование запросов.

Параметр `algorithm` определяет алгоритм генерации хешей из текстовых частей писем (для вложений и изображений всегда используется [blake2b](https://blake2.net/)). Исторически в rspamd использовался алгоритм siphash. Однако он имеет определенные проблемы с производительностью, особенно на устаревшем "железе" (cpu до Intel Haswell). Поэтому если вы создаете собственное хранилище, то стоит рассмотреть другие, более быстрые алгоритмы:

* `xxhash`
* `mumhash`
* `fasthash`

Для большинства задач я рекомендую использовать `mumhash` или `fasthash`, которые демонстрируют отличную производительность на множестве платформ. Для более точной информации вы можете собрать набор тестов в rspamd:

```
$ make rspamd-test
```

и запустить тест различных вариантов алгоритмов хешей на вашей платформе:

```
test/rspamd-test -p /rspamd/shingles
```

**Важное замечание:** задав однажды, возможности изменить этот параметр без потери всех данных в хранилище, так как все хеши создаются, используя конкретный алгоритм, а восстановление текста по хешу невозможно принципиально.
